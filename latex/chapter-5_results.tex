\chapter{Results}
\label{chap:results}

While the presented solution addresses the need for a privacy preserving, secure data collection tool, there are some points, that could not be addressed. 
Using the structure of DNS we were able to detach the clients IP from the data, which, in turn, is transported encrypted utilizing asynchronous encryption. 

In this chapter we provide information of our evaluation steps and discuss the results of our measurement setup described in the last chapter.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations of the collection}
\label{sec:measurement:robust}
%

    We looked into ways to validate the collected data. If development is based on on the data, adversaries might try to generate emulated devices. To counter the emulation, we only use physical devices with PCI addresses for the ID generation. This excludes Linux containers like docker without network card passthrough. The message buffer of the kernel is checked if the kernel is loaded in a virtual environment like KVM or Virtualbox. The client checks this, using the \textit{dmesg} application. 
    If a virtual environment is detected, the client stops before transmitting any data.\\
    
    Another option to check for validity is to check the integrity of the source code. Therefore a hash or similar can be generated over the existing source code and transmitted to the server.
    If a cryptographic hash function is used, source code modification would show in the hash value transmitted.\\
    This, and other options can be leveraged with patching the source code. Especially in open source software it is easy to manipulate the software. The function that generates the hash of the source code can be pointed to intact source code, while the running code is modified. While it is more complicated, the same is true for closed source software.
    Using a closed source implementation for data collection in an open source project might reduce users' trust in a project and make them stop using it.
    Changing the MAC address of a physical device can be used to manipulate the collection as well. This can be countered on MTD devices by basing the ID generation on the persistent MTD partitions only. For devices without persistent special data partitions, there is currently no work around in dalec.\\
    
    To increase the complexity of manipulation, a user authentication process would be needed. If a malicious actor would need to create one account or token per counterfeit device, the manipulation possibilities could be limited. On the other hand, users with a multitude of legitimate devices would be burdened additionally.\\ 
    As we pointed out in previous chapters, this would reduce the number of participating users, even with privacy preserving schemes available.\\

    
    While our system provides privacy, the generated traffic might look malicious.
    In strongly regulated or monitored environments the DNS requests might trigger data exfiltration alerts. As this might lead to the collecting domain ending up on a distributed block list or a drop of all traffic from a client. That may cause issues for other clients in less regulated environments, which solely block DNS requests based on these lists.
    Therefore, clients should be made aware of the data collection layout. The collection domain should ideally state its purpose and be openly documented. Blocking might be prevented that way, as network operator might check on domain names before blocking, if the core domain does not look suspicious.\\

    If a project intents to publish data, that is based on PII, all data sets should be checked against the privacy publishing models we presented in section \ref{subsec:related:private_data_analysis}. While we recommend to avoid the collection of personally identifiable data, there might be reason to do so.\\
    There are some open source tools available to ease the privacy preserving analysis.
    For differential privacy, there are tools developed by IBM \cite{noauthor_ibmdifferential-privacy-library_2021}, Google \cite{noauthor_googledifferential-privacy_2021} or the Harvard University Privacy Tools Project \cite{salil_vadhan_opendp_nodate}. These tool provide support for developers, who want to use differential privacy in there applications and analyses.
    Tools for \textit{k-}anonymity and \textit{l-}diversity are available as well. 
    Google provides a solution to calculate values for both algorithms \cite{noauthor_computing_nodate}, \cite{noauthor_computing_nodate-1}. 
    Crowds \cite{mazzone_leo-mazzcrowds_2021} is a Python module that transforms Pandas dataframes with the Optimal Lattice Anonymization algorithm, that they satisfy \textit{k-}anonymity. An implementation for \textit{l-}diversity \cite{gong_qiyuangongmondrian_l_diversity_2021} and \textit{k-}anonymity \cite{gong_qiyuangongmondrian_2021} using the Mondrian algorithm for anonymization is available is well.

%
\newpage
%
 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Anonymization Results}
\label{sec:results:anon}
    devices with a single network interface card and no bootloader or configuration partitions. During the transport the user data is encrypted. An adversary that monitors the traffic of a client could collect the collection query, but without the private key the collected data is of no use. If an attacker knows the vendor of the network interface card, there are still $2^{24} = 16777216$ hashes to generate and encrypt, which is an relatively easy task for modern hardware. If the attacker already obtained the vendor ID, there is only little insight gained from it, especially, if the collected data is stored with a second layer encryption using compute intense algorithms like \textit{b}- or \textit{scrypt}. 
    Then again, if the offender is unaware of the network device manufacturer, the search spaces for MAC generation increases significantly.
    For multi-MAC devices the number of MAC addresses is large enough to be unfeasible to generate and apply encryption.


- number of available mac addresses -> 1 interface geräte ansprechen
- Sicherheit der ID auch bei nur einer MAC
- daten während der übertragung verschlüsselt, angreifer nicht einsehen, größerer suchraum.
- wenn zusätzlich verschlüsselt gespeichert noch aufwendiger aus möglicher range ID zu generieren
- Thread model
- eine Anfrage kommt über mehrere DNS server


%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Telemetry statistics}
\label{sec:results:telemetry}
%
- Netzwerk Footprint. Viele clients gleichzeitig -> Datenverbrauch
- number of device handlebar
- Multithreading

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary}
In this chapter, we demonstrated the limitations of the system. We also discussed the security of the generated IDs during transport and storage phase. Especially for devices with only one physical interface this is critical. We also discussed about the performance 


