%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   CAPTER 3   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Software Design}
\label{chap:software_design}

As mentioned in the previous chapter, we are going to focus on the challenges faced when utilizing the domain name system. Before we discuss the transport of data through the hierarchical name system in section \ref{sec:software_design:tx}, we will have at look at the data collection and ID generation (\ref{sec:software_design:data_collection}.\\
Section \ref{sec:software_design:ref_impl} demonstrates how we realized the proposed solutions in the reference implementation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Parameter}
%\label{sec:measurement:parameter}

%

%\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Collection}
\label{sec:software_design:data_collection}
    As we have shown in \ref{subsec:related:pii} and \ref{subsec:related:law} it is wise to avoid the collection of PII. While it may be avoidable for the statistical data and numeric values, this might not be possible for the generated ID.\\
    The ID should be unique to identify a device persistent over reboots and system updates, but don't allow to draw conclusions on a device.
    While the gathered data needs to be useful to the purpose of the collection, the collection practices need to be compliant to the according privacy laws as well. 
    
 %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Data selection}
        \label{subsec:software_design:selection}
        To get the most out of data collection it needs to be relevant to the task it has to fulfill.
        While a wide range of collected metrics might help to broaden the view over the landscape that is monitored, it may hinder in the evaluation and detection of relevant data points. Therefore data collection should always be kept to a minimum needed to help the cause for the collection.\\
        In addition user are more willing to share non sensitive as Woldaregay et al. \cite{woldaregay_user_2020} have shown for medical data, Ziefle et al.\cite{ziefle_users_2016} for data sharing on social networks and Leon et al. \cite{leon_what_2013} for sharing information with online advertiser. Furthermore Schneegrass et al. \cite{10.1145/3290605.3300753} have shown, that the willingness of information sharing for sensory data is based on a positive or negative connotation of the data in question.\\
        
        As we discuss Internet connected data collections, there is always the possibility for a data breach, or an adversary actor, who may target the collected data. If PII is contained in the data set, the possible yield for an attacker is higher, compared to public non personal identifiable data.\\
        To protect the devices and thereby the users identity, numerical data should always be collected in bins or ranges.\\
        The exact amount of available memory in a system provided in byte or even kilobyte may fingerprint a device. IP and MAC addresses are sensitive data as well and should not be collected at all, as these could be connected to other Internet related activities and lead to an attack on the user, to gain control over their device. \\
        As the National Academies of Science, Engineering and Medicine propose in their Consensus report \cite{groves_federal_2017}, the more attributes are included in a data set the likelier the re-identification of individuals and the greater the threat for external data linking.\\
        
        Prior to collecting data large scale a project should define the intend behind the process. With a clear outline of objectives, relevant parameters can be identified 
        Therefore we propose a minimal data collection set containing only information that are relevant to fulfill the purpose of the collection as recommended by NIST and OECD.\\
        To be open about the collected information, the current state of the collection should be easily available to any user, as well as the reasoning for the collection of each date.
        Following NISTs recommendations again, these data sets should be reviewed on a regular basis, to validate that each date is still needed.\\
        
        The objective for an open source project could be to reduce the amount of defects in the released software, or  to collect usage statistics to improve the development of the software for a given target. A combination of objectives is possible as well.\\
        Based on the objectives, a list of parameter can be compiled to retrieve data relevant to the purpose.
        To e.g. detect system crashes, the time since last reboot (uptime) of a given device may be relevant, as well as the amount of memory available and the CPU/SoC. Further on, the software version in use needs to be included in this example. These are all non-PII and may be collected without further obfuscation. As we have stated before, it is recommended to 
        classify numeric values, like available memory into categories.\\
        
        Although the collected information don't need to be obfuscated, the user should be made aware of the data collection. In some cases the users acknowledgment might be required as well. Therefore banner, push notifications or notifications on installation or first execution should be shown to the user. \\
        In case of a Linux distribution this could be done by a pop message on first login to graphical screen or using a banner on a remote or serial login to the device.
        The GDPR requires that consent must be given specifically and may be withdrawn at any time\cite{noauthor_gdpr_2020}.\\ 
        Therefore a Linux distribution might require to click or set a value to enable data collection. An IoT firmware, like Tasmota might need to enable data collection via a web interface for a device. This needs to be done, before any user information is collected\\ 
        
        Furthermore an organization should provide a privacy policy for the data collection, even if no PII is collected. It should state which information is collected and transmitted on a given device.\\
        This could be seen as good faith and increase the users trust in in the data collection program. If private information is collected a privacy policy is required be GDPR. Another important point to be compliant is the right to be forgotten. This make an identifier an important factor to recognize the users data, that should be removed.
        
          
    \subsection{ID generation}
        \label{subsec:software_design:id}
        To identify devices on a reliable and reproducible basis the ID generation is based on hardware information available and is therefore persistent through a reboot, a re-flash or an update.\\
        We recommend the use of the available MAC-addresses. These should be hashed individually and and combined into one string which is then hashed again. Both hashing operations should be done with a strong cryptographic hashing function.
        As there are several different hash functions out there, the hashing should be one way and un-keyed. A one way hash function (OWHF) fulfills the requirements for a hash \textbf{\textit{h}} function, which can be seen in equation \ref{eq:hash}\cite{sobti_cryptographic_2012}.
        
        \begin{equation}
            \label{eq:hash}
            h : D \longrightarrow R
        \end{equation}
        
        where domain $D = \{0,1\}^*$ and $R=\{0,1\}^n$ for $n >= 1$.
        
        In Addition an OWHF must meet five requirements defined by Merkle in \cite{merkle_secrecy_1979}.
        \begin{itemize}
            \item \textbf{\textit{h}} must be applicable to any length of data blocks
            \item A fixed length output is created by \textbf{\textit{h}}
            \item A message digest \textbf{\textit{h}}(x) with \textbf{\textit{h}} and x given
            \item If \textbf{\textit{h}} and \textbf{\textit{h}}(x) are known, it is computationally infeasible to find x
            \item If \textbf{\textit{h}} and \textbf{\textit{h}}(x) are known, it is computationally infeasible to find x and x' so that $\textbf{\textit{h}}(x) = \textbf{\textit{h}}(x')$
        \end{itemize}
        
        This function should come from the Secure Hash Algorithm 2 (SHA-2) family. While SHA512 is the stronger function and is recommended, it is not available on all devices.\\
        A single MAC consists of 48 bit, from which 24 bit are a vendor specific and equal over all devices from this vendor. The other 24 bit are a unique identifier for a given network interface. As most internet connected devices come with pre-installed/soldered network interfaces, this could lead to brute force attempts to regenerate the MAC-address from a hash. Especially on hardware with only one physical network interface. With the power jump in recent graphic card generations a hash that is only based on 24 unique bits can be brute forced in very short time. Therefore the generated hash needs to be enhanced.\\
        
        There are some will known ways to enhance security on stored passwords and similar tasks. Three of them are PBKDF2\cite{kaliski_pkcs_2000}, Bcrypt\cite{provos_future-adaptable_1999} and Scrypt\cite{josefsson_scrypt_2016}.
        
        Bcrypt
        
        Scrypt is a password based key derivation function which was designed to be computational complex to increase the costs of hardware based attacks. It creates a key from a list of inputs, that define the cost of the function.
        
        This reinforcement can be achieved with a key derivation function (KDF). These functions have two use cases. On the one hand they are used for password hashes in modern operating systems, protecting the users password against easy access\cite{percival_stronger_nodate}. 
        The other use case is the derivation of a key based on a token and another key\cite{camenisch_privacy_2011}. Attacking a KDF in itself is not feasible. An attacker would need to iterate over a range of passwords or regular expressions and apply the KDF to them\cite{percival_stronger_nodate}.\\
        One example of such a derivation function is Password-Based Key Derivation Function 2 (PBKDF2), in which a pseudo-random function is applied to a given password and salt for a number of iterations. 
        This reduces it's vulnerability against brute force and dictionary attacks attacks in which an adversary either starts guessing passwords and applies the function to it's guesses, or uses a set of rules or words from a list.  \cite{kaliski_bkaliskirsasecuritycom_pkcs_2000}. 
        Computation time increases significantly for strong passwords and salts, making rainbow table attacks less feasible.
        To keep IDs reproducible we need to derive our password and salt from data provided by the device, which wont alter during a reinstall of a system. For devices with non volatile flash memory the Memory Technology Devices (MTD) are usually devices with solid state file systems\cite{giometti_mtd_2017}\cite{woodhouse_memory_nodate}. These partitions can contain configuration information for wireless devices. This contains device-unique data which is ideal to use as key and/or salt.
        To further strengthen the ID against brute forcing and decreasing the amount of character used in a DNS query, the generated ID should be reduced to fewer bytes.\\
        
        
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Transmission}
\label{sec:software_design:tx}
%
     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Data Encryption}
        \label{subsec:software_design:encryption}
        

     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Fitting data to DNS request}
        \label{subsec:software_design:fitting}
        As elements from the domain name system are required to support [a-z], [0-9] and hyphens only the data needs to be transformed to a format that can be transmitted reliable. Upper case letters are hereby treated the same as lower case ones.
        For example EXAMPLE.COM. would lead to the same result as example.com. and ExAmPlE.com..
        Therefore a base 32 encoding would be feasible to keep the transmission size as low as possible. In addition it offers the widest set of supported symbols, while using only one symbol, that is not supported by DNS. The equal sign is used as a padding character, which needs to be exchanged with a hyphen to make it conforming. The hyphen can be used as padding symbol, as it is not present in the RFC 4648 base 32 alphabet\cite{josefsson_simonjosefssonorg_base16_2006}. base 16 encoding would reduce the amount of available symbols below the supported range of symbols, while base 64 encoding would add additional symbols, which are not supported in the domain name system. These are the plus '+' and and slash '/' symbol. Base 64 keeps the equal sign for padding, which makes a DNS conform substitution harder.\\
        A URL and filename safe base 64 alphabet variant is mentioned in RFC 4648 as well, which replaces the plus sign with the minus and the slash symbol with an underscore, while keeping '=' as the padding character. Again this makes a valid substitution hard and unnecessary as all relevant symbols are already covered in the Base 32 alphabet.\\
        
    TODO: DNS Label etc \cite{mockapetris_domain_1987}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reference Implementation}
\label{sec:software_design:ref_impl}

%
\subsection{Data Collection}

%
\subsection{ID generation}
    To generate a unique ID for a given device we are collecting all available MAC addresses and combine them in one colon-free string. This string is passed to the \textit{openssl sha512} hash function. These hashes are concatenated into one long string, which is than hashed again and called our ID. As we go for \textit{openssl} as a dependency for PBKDF2 we are using it's \textit{SHA512} digest function to generate stronger hashes. The resulting hash is than passed to the encrypt function of \textit{openssl} utilizing \textit{aes256-cbc} and PBKDF2 with 10.000 iterations.
    The Salt and key depend on the devices hardware. If MTD partitions are available, we hash these partitions and use the first 16 byte of the resulting hash as salt. The remaining Bytes are used as the key. If no such partitions are available, the ID, generated in the  previous step, is used for salt and key
     sha512
     pbkdf2
     aes256
     mtd 
     
     We further enhance the brute forcing protection in reducing the generated hash to the first 32 Byte, which leaves around $1.158e^{77}$ possible combinations. While this makes it nearly impossible to recreate the original ID and MAC address, the probability of a hash collision (two hashes are equal to each other) is increased. In [TODO] the hash collision probability is calculated as seen in equation \ref{eq:base_prob_hash}.
     
     \begin{equation*}
         N = 2^{Number\ of\ Bits\ in\ Hash}
     \end{equation*}
     
     \begin{equation}
         \label{eq:base_prob_hash}
         P(k,N) = 1 - \exp{\frac{-k(k-1)}{2 * N}}
     \end{equation}
     
     Based on \cite{TODO} equation \ref{eq:base_prob_hash} can be simplified for expected collisions probabilities of $\frac{1}{10}$ or less to
     
     \begin{equation}
         \label{eq:simp_prob_hash}
         P(k,N) = \frac{k(k - 1)}{2N} 
     \end{equation}
     
     To calculate the number of hashes $k$ before a collision occurs under a given probability $P$, equation \ref{eq:simp_prob_hash} must be solved for $k$.
     
     \begin{equation*}
         P = \frac{k(k - 1)}{2N}
     \end{equation*}
     \begin{equation*}
         2NP = k (k - 1)
     \end{equation*}
     \begin{equation*}
         2NP = k^2 - k
     \end{equation*}

     \begin{equation}
        \label{eq:k_hash}
         0 = k^2 - k - 2NP
     \end{equation}
     
     Equation \ref{eq:k_hash} is a reduced quadratic equation and can be solved in a simplified variation as seen in \ref{eq:pq-simp}
     
     \begin{equation}
         \label{eq:pq-simp}
         k = \sqrt{2NP}
     \end{equation}
     
     For a given collision probability of $P = \frac{1}{10^{18}}$ and $N = 2^{32 * 8} = 2^{256}$ bit equation \ref{eq:pq-simp} results in $x * 10^{29}$ hashes before two hashes may match each other.
     
     \begin{equation}
         \label{eq:32B_solve}
         k = \sqrt{2 * 2^{256} * \frac{1}{10^{18}}} = x * 10^{29}
     \end{equation}
     
     If we compare equation \ref{eq:32B_solve} with \ref{eq:129B_solve}, which uses the original 129 Byte SHA512 the possibility for a hash collision is increased, but even with \ref{eq:32B_solve} the collision probability is very low.
     
     \begin{equation}
         \label{eq:129B_solve}
         k = \sqrt{2 * 2^{(129 * 8)} * \frac{1}{10^{18}}} = ...
     \end{equation}
     
     Out of 245 octillion hashes two will match with a $\frac{1}{10^18}$ chance. 
     
     1 percent chance that two devices generate same hash
     berechnen und ins verh√§ltnis stellen
     
     
% 
\subsection{Data handling}
    As base32 is a package in OpenWrt with multiple dependencies we decided to go for a base16 encoding instead. This is available with \textit{hexdump}, which is included in most basic OpenWrt setups. While this increases the numbers of messages, that are needed to be send, it reduces the memory footprint for the statistics tool.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary}

In this chapter, we gave an introduction to the data collection application (\ref{sec:software_design:data_collection} and described the concept of data transmission in (section \ref{sec:software_design:tx}).
We also introduced the reference implementation for the proposed solution in section \ref{sec:software_design:ref_impl}. 
%