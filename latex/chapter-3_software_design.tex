%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   CAPTER 3   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Software Design}
\label{chap:software_design}

As mentioned in the previous chapter, we are going to focus on the challenges faced when collecting 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Parameter}
%\label{sec:measurement:parameter}

%

%\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Collection}
\label{sec:software_design:data_collection}

 %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Data selection}
        \label{subsec:software_design:selection}
        To get the most out of data collection it needs to be relevant to the task it has to fulfill.
        While a wide range of collected metrics might help to broaden the view over the landscape that is monitored, it may hinder in the evaluation and detection of relevant data points. Therefore data collection should always be kept to a minimum needed to help the cause for the collection.\\
        In addition user are more willing to share non sensitive as \cite{TODO} has shown for medical data, \cite{TODO} for data sharing on social networks and \cite{TODO} for sharing information with online advertiser. Furthermore \cite{TODO} have shown, that the willingness of information sharing for sensory data is based on a positive or negative connotation of the data in question.\\
        
        As we discuss Internet connected data collections, there is always the possibility for a data breach, or an adversary actor, who may target the collected data. If PII is contained in the data set, the possible yield for an attacker is higher, compared to public non personal identifiable data.\\
        To protect the devices and thereby the users identity, numerical data should always be collected in bins or ranges.\\
        The exact amount of available memory in a system provided in byte or even kilobyte may fingerprint a device. IP and MAC addresses are sensitive data as well and should not be collected at all, as these could be connected to other Internet related activities and lead to an attack on the user, to gain control over their device. \\
        As the National Academies of Science, Engineering and Medicine propose in their Consensus report \cite{TODO} https://www.nap.edu/read/24893/chapter/7#87, the more attributes are included in a data set the likelier the re-identification of individuals and the greater the threat for external data linking.\\
        
        Prior to collecting data large scale a project should define the intend behind the process. With a clear outline of objectives, relevant parameters can be identified 
        Therefore we propose a minimal data collection set containing only information that are relevant to fulfill the purpose of the collection.
        
        The objective for an open source project could be to reduce the amount of defects in the released software, or  to collect usage statistics to improve the development of the software for a given target. A combination of objectives is possible as well.\\
        Based on the objectives, a list of parameter can be compiled to retrieve data relevant to the purpose.
        To e.g. detect system crashes, the time since last reboot (uptime) of a given device may be relevant, as well as the amount of memory available and the CPU/SoC. Further on, the software version in use needs to be included in this example.
        
        
          
    \subsection{ID generation}
        \label{subsec:software_design:id}
        To identify devices on a reliable and reproducible basis the ID generation is based on hardware information available and is therefore persistent through a reboot, a re-flash or an update.\\
        We recommend the use of the available MAC-addresses and combine them into one string which is then hashed with the a strong cryptographic hashing function.
        This function should come from the Secure Hash Algorithm 2 (SHA-2) family. While SHA512 is the stronger function and is recommended, it is not available on all devices.\\
        A single MAC consists of 48 bit, from which 24 bit are a vendor specific and equal over all devices from this vendor. The other 24 bit are a unique identifier for a given network interface. As most internet connected devices come with pre-installed/soldered network interfaces, this could lead to brute force attempts to regenerate the MAC-address from a hash, especially on hardware with only one physical network interface. Therefore the generated hash needs to be enhanced.\\
        This enforcement can be achieved with a key derivation function (KDF). These functions have two use cases. On the one hand they are used for password hashes in modern operating systems protecting the users password against easy access\cite{percival_stronger_nodate}. 
        The other use case is the derivation of a key based on a token and another key\cite{camenisch_privacy_2011}. Attacking a KDF in itself is not feasible. An attacker would need to iterate over a range of passwords or regular expressions and apply the KDF to them\cite{percival_stronger_nodate}.
        One example of such a derivation function is Password-Based Key Derivation Function 2 (PBKDF2), in which applies a pseudo-random function to a given password and salt for a number of times. This reduces it's vulnerability against brute force attacks\cite{kaliski_bkaliskirsasecuritycom_pkcs_2000}. 
        Computation time increases significantly for strong passwords and salts, making rainbow table attacks less feasible. 
        To keep IDs reproducible we need to derive our password and salt from data provided by the device, which wont alter during a reinstall of a system. For devices with non volatile flash memory the Memory Technology Devices (MTD) are usually devices with solid state file systems\cite{giometti_mtd_2017}\cite{woodhouse_memory_nodate}. These partitions can contain configuration information for wireless devices. This contains device-unique data which is ideal to use as key and/or salt.
        To further strengthen the ID against brute forcing and decreasing the amount of character use in a DNS query, the generated ID should be reduced to fewer bytes.\\
        
\newpage



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Transmission}
\label{sec:software_design:tx}
%
     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Data Encryption}
        \label{subsec:software_design:encryption}
        

     %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%% Subsection %%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %
    \subsection{Fitting data to DNS request}
        \label{subsec:software_design:fitting}
        As elements from the domain name system are required to support [a-z], [0-9] and hyphens only the data needs to be transformed to a format that can be transmitted reliable. Upper case letters are hereby treated the same as lower case ones.
        For example EXAMPLE.COM. would lead to the same result as example.com. and ExAmPlE.com..
        Therefore a base 32 encoding would be feasible to keep the transmission size as low as possible. In addition it offers the widest set of supported symbols, while using only one symbol, that is not supported by DNS. The equal sign is used as a padding character, which needs to be exchanged with a hyphen to make it conforming. The hyphen can be used as padding symbol, as it is not present in the RFC 4648 base 32 alphabet\cite{josefsson_simonjosefssonorg_base16_2006}. base 16 encoding would reduce the amount of available symbols below the supported range of symbols, while base 64 encoding would add additional symbols, which are not supported in the domain name system. These are the plus '+' and and slash '/' symbol. Base 64 keeps the equal sign for padding, which makes a DNS conform substitution harder.\\
        A URL and filename safe base 64 alphabet variant is mentioned in RFC 4648 as well, which replaces the plus sign with the minus and the slash symbol with an underscore, while keeping '=' as the padding character. Again this makes a valid substitution hard and unnecessary as all relevant symbols are already covered in the Base 32 alphabet.\\
        
    TODO: DNS Label etc \cite{mockapetris_domain_1987}
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reference Implementation}
\label{sec:software_design:ref_impl}

%
\subsection{Data Collection}

%
\subsection{ID generation}
    To generate a unique ID for a given device we are collecting all available MAC addresses and combine them in one colon-free string. This string is passed to the \textit{openssl sha512} hash function. These hashes are concatenated into one long string, which is than hashed again and called our ID. As we go for \textit{openssl} as a dependency for PBKDF2 we are using it's \textit{SHA512} digest function to generate stronger hashes. The resulting hash is than passed to the encrypt function of \textit{openssl} utilizing \textit{aes256-cbc} and PBKDF2 with 10.000 iterations.
    The Salt and key depend on the devices hardware. If MTD partitions are available, we hash these partitions and use the first 16 byte of the resulting hash as salt. The remaining Bytes are used as the key. If no such partitions are available, the ID, generated in the  previous step, is used for salt and key
     sha512
     pbkdf2
     aes256
     mtd 
     
     We further enhance the brute forcing protection in reducing the generated hash to the first 32 Byte, which leaves around $1.158e^{77}$ possible combinations. While this makes it nearly impossible to recreate the original ID and MAC address, the probability of a hash collision (two hashes are equal to each other) is increased. In [TODO] the hash collision probability is calculated as seen in equation \ref{eq:base_prob_hash}.
     
     \begin{equation*}
         N = 2^{Number\ of\ Bits\ in\ Hash}
     \end{equation*}
     
     \begin{equation}
         \label{eq:base_prob_hash}
         P(k,N) = 1 - \exp{\frac{-k(k-1)}{2 * N}}
     \end{equation}
     
     Based on \cite{TODO} equation \ref{eq:base_prob_hash} can be simplified for expected collisions probabilities of $\frac{1}{10}$ or less to
     
     \begin{equation}
         \label{eq:simp_prob_hash}
         P(k,N) = \frac{k(k - 1)}{2N} 
     \end{equation}
     
     To calculate the number of hashes $k$ before a collision occurs under a given probability $P$, equation \ref{eq:simp_prob_hash} must be solved for $k$.
     
     \begin{equation*}
         P = \frac{k(k - 1)}{2N}
     \end{equation*}
     \begin{equation*}
         2NP = k (k - 1)
     \end{equation*}
     \begin{equation*}
         2NP = k^2 - k
     \end{equation*}

     \begin{equation}
        \label{eq:k_hash}
         0 = k^2 - k - 2NP
     \end{equation}
     
     Equation \ref{eq:k_hash} is a reduced quadratic equation and can be solved in a simplified variation as seen in \ref{eq:pq-simp}
     
     \begin{equation}
         \label{eq:pq-simp}
         k = \sqrt{2NP}
     \end{equation}
     
     For a given collision probability of $P = \frac{1}{10^{18}}$ and $N = 2^{32 * 8} = 2^{256}$ bit equation \ref{eq:pq-simp} results in $x * 10^{29}$ hashes before two hashes may match each other.
     
     \begin{equation}
         \label{eq:32B_solve}
         k = \sqrt{2 * 2^{256} * \frac{1}{10^{18}}} = x * 10^{29}
     \end{equation}
     
     If we compare equation \ref{eq:32B_solve} with \ref{eq:129B_solve}, which uses the original 129 Byte SHA512 the possibility for a hash collision is increased, but even with \ref{eq:32B_solve} the collision probability is very low.
     
     \begin{equation}
         \label{eq:129B_solve}
         k = \sqrt{2 * 2^{(129 * 8)} * \frac{1}{10^{18}}} = ...
     \end{equation}
     
     Out of 245 octillion hashes two will match with a $\frac{1}{10^18}$ chance. 
     
     1 percent chance that two devices generate same hash
     berechnen und ins verhältnis stellen
     
     
% 
\subsection{Data handling}
    As base32 is a package in OpenWrt with multiple dependencies we decided to go for a base16 encoding instead. This is available with \textit{hexdump}, which is included in most basic OpenWrt setups. While this increases the numbers of messages, that are needed to be send, it reduces the memory footprint for the statistics tool.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   SECTION   %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary}

In this chapter, we gave an introduction to the data collection application (\ref{sec:software_design:data_collection} and described the concept of data transmission in (section \ref{sec:software_design:tx}).
We also introduced the reference implementation for the proposed solution in section \ref{sec:software_design:ref_impl}. 
%